---
title: Contr√¥le de flux
author: 
  - "üë§[S√©bastien Boisg√©rault](mailto:Sebastien.Boisgerault@mines-paristech.fr), 
    üè¶ MINES ParisTech, Universit√© PSL"
date: "‚öñÔ∏è Licence : [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)"
# author: ""
# license: [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)
---

# Intro

# Script

D√©roulement lin√©aire du programme, ligne par ligne ...

# What if?

Ex√©cution conditionnelle de code, "branching".

## Bool√©ens

Type bool√©en, op√©rateurs logiques, conversion en bool√©en des types built-in

### Op√©rateurs logiques

`and`, `or`, priorit√©s.

### Conversion

**en quelque sorte fausse** (üá∫üá∏ *false-ish*) ou **en quelque sorte vraie** (üá∫üá∏ *true-ish*)



``` python
>>> x = None
>>> bool(x)
False
```

| `type(x)`    | `bool(x) is False` | `bool(x) is True` |
|--------------|--------------------|-------------------|
| `bool`       | `x is False`       | `x is True`       |
| `int`        | `x == 0`           | `x != 0`          |
| `float`      | `x == 0.0`         | `x != 0.0`        |
| `complex`    | `x == 0.0j`        | `x != 0.0j`       |
| `str`        | `x == ""`          | `x != ""`         |
| `bytes`      | `x == b""`         | `x != b""`        |
| `tuple`      | `len(x) == 0`      | `len(x) > 0`      |
| `list`       | `len(x) == 0`      | `len(x) > 0`      |
| `set`        | `len(x) == 0`      | `len(x) > 0`      |
| `dict`       | `len(x) == 0`      | `len(x) > 0`      |

#### ü§î Quelle est la logique de cette conversion ? {.details .info}

Pour tous les types standards list√©s ci-dessus : 

  - Si `x` est num√©rique (`bool`, `int`, `float`, `complex`), 
    il est en quelque sorte vrai si et seulement s'il est non-nul : 

    ``` python
    bool(x) == (x == 0)
    ```

  - Si `x` est un conteneur (`str`, `bytes`, `tuple`, `list`, `set`, `dict`),
    il est en quelque sorte vrai si et seulement s'il est vide :

    ``` python
    bool(x) == (len(x) == 0)
    ```

#### TODO:

  - objets, par d√©faut ? `True` (sinon, √† setter √† `None`)

  - exploration autres types : files (tjs `True`), numpy arrays, xml element, etc. ?
    Array int√©ressant: pas oblig√© d'√™tre convertible ; m√©lange de warnings,
    erreurs, et qui marche. Plus simple de ne pas se fier √† la conversion
    implicite! Utiliser `.size` est le plus souvent ce que l'on veut. Sinon,
    utiliser `.any()` ou `.all()`.

## `If`

  - if

  - if-elif

  - if-else

  - conversion implicite en bool√©en.

# Boucles

## `While`

  - `while stuff`

  - `break`, `continue`

  - `while True` (?)

## `For`

  - `for x in y`, types builtins

  - it√©rable et appels explicites (ex sur un dict)

## Fonctions

Impact sur le flux de contr√¥le principalement, et *un peu, ad minimima* 
sur les namespaces ?



## Exceptions

### Erreurs

En cas d'op√©ration invalide, Python g√©n√®re une erreur ; par exemple si vous 
divisez $1$ par $0$, calculez $\sqrt{-1}$ ou √©valuez la valeur absolue
d'une liste vide, vous observez les messages suivants :

``` python
>>> 1.0 / 0.0
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ZeroDivisionError: float division by zero
```

``` python
>>> import math
>>> math.sqrt(-1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: math domain error
```

``` python
>>> abs([])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: bad operand type for abs(): 'list'
```

Techniquement, Python g√©n√®re une erreur en **levant une exception**.
L'exception se manifeste en affichant : 

  - un **traceback** pointant vers l'origine de l'erreur :
    
    `File "<stdin>", line 1, in <module>`

    (ici assez peu instructif il faut bien l'avouer.)

  - son **type** :
  
    - `ZeroDivisionError`, 
    
    - `ValueError` et 
    
    - `TypeError`.

  - un **message** explicatif: 
  
    - `"division by zero"`, 
    
    - `"math domain error"`, 

    - `"bad operand type for abs(): 'list'"`


#### What about NumPy? {.details .info}

Les calculs erron√©s sont g√©r√©s diff√©rents par Python standard et NumPy. 
L√† o√π Python standard g√©n√®re des exceptions en pr√©sence de calculs invalides, 
NumPy permet d'utiliser des valeurs num√©riques sp√©ciales telles que `inf` ($+\infty$)
et `nan` (Not-A-Number ou $\bot$). Ainsi:

``` python
>>> import numpy as np
>>> _ = np.seterr(all="ignore")
>>> np.float64(1.0) / np.float64(0.0)
inf
>>> np.sqrt(-1.0)
nan
```


#### Misc. Sandbox.

jdskdjslkd sdlj k jslkdj slkjd

``` python
>>> import numpy as np
>>> _ = numpy.seterr(all="ignore")
>>> np.sqrt(-1)
nan
>>> float64(1.0) / float64(0.0)
inf
```


#### ksdsmkd

  - Exposer les cons√©quences des "erreurs" dans un script, comment elles
    affectent l'ex√©cution. Ca affecte bien le flot d'ex√©cution!

  - Montrer l'impact dans une fonction ; puis dans des fonctions imbriqu√©es.

  - G√©rer les exceptions: `try/except` 

  - "Filtrage" des exceptions attrap√©es (puis multiplication des filtres)

  - `Try/except/finally` 

  - re-raise ? Ou apr√®s avoir appris comment lever une exception ?

  - Lever une exception (built-in ; √ßa suffira)


Sandbox
================================================================================

TODO quizz:

  - metadata to enable the stuff (selectively). Enable or disable by default?

  - metadata to have radio buttons instead of checkboxes 
    (we need to provide a common name then)

#### Quizz
Whadda whadda

- [ ] A

- [ ] B

- [ ] C

#### ‚ú® Solution {.details}

- [x] A

- [x] B

- [ ] C

#### ‚ú® **Solution**

::: collapse :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


- [x] A

- [x] B

- [ ] C

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::