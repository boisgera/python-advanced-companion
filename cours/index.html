<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Fonctions</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="css/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!--
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet"> 
  -->

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap" rel="stylesheet"> 
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap" rel="stylesheet">
  <script>
      document.addEventListener("DOMContentLoaded", (event) => {
          let h3 = document.createElement("h3");
          h3.innerHTML = "Table des matières";
          let toc = document.getElementById("TOC");
          toc.prepend(h3);
      });    
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Fonctions</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#fonctions">Fonctions</a>
<ul>
<li><a href="#aperçu">Aperçu</a></li>
<li><a href="#valeurs-de-retour-todo">Valeurs de retour (TODO)</a></li>
<li><a href="#espaces-de-nom-todo">Espaces de nom (TODO)</a></li>
</ul></li>
<li><a href="#invocables">Invocables</a>
<ul>
<li><a href="#types">Types</a></li>
<li><a href="#méthodes">Méthodes</a></li>
<li><a href="#instances">Instances</a></li>
</ul></li>
<li><a href="#fonctions-génératrices">Fonctions génératrices</a></li>
<li><a href="#programmation-fonctionnelle">Programmation fonctionnelle</a>
<ul>
<li><a href="#lambda">Lambda</a></li>
<li><a href="#fermetures">Fermetures</a></li>
<li><a href="#décorateurs">Décorateurs</a></li>
</ul></li>
</ul>
</nav>
<h2 id="fonctions">Fonctions</h2>
<h3 id="aperçu">Aperçu</h3>
<pre class="python"><code>def fibonacci(n, start=(0, 1)):
    &quot;Return a list of n Fibonnaci numbers.&quot;
    result = []
    a, b = start
    while len(result) &lt;= n:
        result.append(a)
        a, b = b, a+b
    return result</code></pre>
<p><code>def</code>, arguments, valeurs par défaut, arguments optionnels, signature, <code>return</code></p>
<pre class="python"><code>&gt;&gt;&gt; numbers = fibonacci(10)
&gt;&gt;&gt; numbers
[0, 1, 1, 2, 3, 5, 8]
&gt;&gt;&gt; numbers = fibonacci(20, start=(5,8))
&gt;&gt;&gt; numbers
[5, 8, 13]</code></pre>
<p>invocation (appel), arguments optionnels, argument spécifiés par position ou par nom.</p>
<p><strong>TODO</strong> <code>def</code> <code>return</code>, retour réifiés (tuple), arguments positionnels ou nommés, arguments par défaut (immutabilité, <code>None</code>, etc.).</p>
<pre class="python"><code>def f(x, y, z=0):
    print(&quot;Please !&quot;)
    return 42</code></pre>
<p>Mentionner type hints (ex avec Typer ?).</p>
<h3 id="valeurs-de-retour-todo">Valeurs de retour (TODO)</h3>
<h3 id="espaces-de-nom-todo">Espaces de nom (TODO)</h3>
<p>Portée / scope</p>
<p>🇺🇸 → Namespace</p>
<p>(implicites)</p>
<p>globals / locals (builtin module ?, read-only, etc.)</p>
<h2 id="invocables">Invocables</h2>
<p>On qualifie d’<strong>invocable</strong> (ou <strong>appelable</strong> ; 🇺🇸 : <strong>callable</strong>) tout objet se comportant comme une fonction, c’est-à-dire pouvant être appelé (invoqué) avec la même syntaxe que les fonctions.</p>
<p>Ainsi, l’entier <code>0</code> n’est pas invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; zero = 0
&gt;&gt;&gt; zero()
TypeError: &#39;int&#39; object is not callable</code></pre>
<p>mais la fonction sans argument qui renvoie <code>0</code> est invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; def zero_fun():
...     return 0
&gt;&gt;&gt; zero_fun()
0</code></pre>
<p>ce qui n’est pas une surprise puisque c’est une fonction !</p>
<pre class="python"><code>&gt;&gt;&gt; type(zero_fun)
&lt;class &#39;function&#39;&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; isinstance(zero_fun, types.FunctionType)
True</code></pre>
<p>L’invocabilité des objets Python peut être testée avec la fonction <code>callable</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(zero)
False
&gt;&gt;&gt; callable(zero_fun)
True</code></pre>
<p>Notons que ce test permet de dire si un objet est invocable, mais pas si on peut l’invoquer sans arguments (ni combien d’arguments sont nécessaires, de quel type, etc.). Ainsi :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(hash)
True</code></pre>
<p>Mais</p>
<pre class="python"><code>&gt;&gt;&gt; hash()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: hash() takes exactly one argument (0 given)</code></pre>
<p>Toutefois</p>
<pre class="python"><code>&gt;&gt;&gt; hash(2**100)
549755813888</code></pre>
<p>Pour en savoir plus sur les arguments attendus, il faudra se reporter à la documentation de l’objet considéré.</p>
<h3 id="types">Types</h3>
<p>Un objet comme <code>int</code> est également invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(int)
True</code></pre>
<p>ce que l’on peut rapidement confirmer expérimentalement :</p>
<pre class="python"><code>&gt;&gt;&gt; int()
0
&gt;&gt;&gt; int(0.0)
0
&gt;&gt;&gt; int(&quot;0&quot;)
0</code></pre>
<p>Pourtant, ce n’est pas une function, mais un type :</p>
<pre class="python"><code>&gt;&gt;&gt; type(int)
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; type(int) is type  # 🤯
True
&gt;&gt;&gt; isinstance(int, types.FunctionType)
False</code></pre>
<p>Rappelons que les types (ou classes) ont vocation, quand on les appelle, à créer des instances du type considéré :</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(int(), int)
True
&gt;&gt;&gt; isinstance(int(0.0), int)
True
&gt;&gt;&gt; isinstance(int(&quot;0&quot;), int)
True</code></pre>
<p>Les classes que vous définissez sont également invocables :</p>
<pre class="python"><code>class Transmogrifier:
    pass</code></pre>
<pre class="python"><code>&gt;&gt;&gt; callable(Transmogriphier)
True
&gt;&gt;&gt; transmogriphier = Transmogriphier()
&gt;&gt;&gt; isinstance(transmogriphier, Transmogrifier)
True</code></pre>
<h3 id="méthodes">Méthodes</h3>
<p>Un <a href="https://calvinandhobbes.fandom.com/wiki/Transmogrifier">transmogriphieur</a> peut transformer son utilisateur en ce qu’il souhaite (par défaut, un tigre 🐯 ; mais on n’a pas spécifié la taille du tigre ! 😉).</p>
<figure>
<img src="https://www.nicepng.com/png/full/198-1980373_calvin-and-hobbes-png-hd-calvin-and-hobbes.png" alt="Calvin transformé en tigre" /><figcaption aria-hidden="true"><a href="https://calvinandhobbes.fandom.com/wiki/Calvin_in_Tiger_Form_(Transmogrifier_alter_ego)">Calvin transformé en tigre</a></figcaption>
</figure>
<pre class="python"><code>class Transmogriphier:
    def __init__(self, turn_into=&quot;tiger&quot;):
        self.turn_into = turn_into
    def activate(self, user):
        return self.turn_into</code></pre>
<pre class="python"><code>&gt;&gt;&gt; transmogriphier = Transmogriphier()
&gt;&gt;&gt; transmogriphier.activate(&quot;calvin&quot;)
&#39;tiger&#39;</code></pre>
<p>L’opération <code>transmogriphier.activate("calvin")</code> n’est pas “atomique” : elle consiste d’abord à obtenir l’attribut <code>activate</code> de l’objet <code>transmogriphier</code>, puis à l’invoquer avec l’argument <code>"calvin"</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; transmogriphy = transmogriphier.activate
&gt;&gt;&gt; callable(transmogriphy)
True
&gt;&gt;&gt; transmogriphy(&quot;calvin&quot;)
&#39;tiger&#39;</code></pre>
<p>Cela est possible car <code>activate</code> est une méthode (liée à l’instance <code>transmogriphier</code> de <code>Transmogriphier</code>) et est donc invocable.</p>
<pre class="python"><code>&gt;&gt;&gt; transmogriphy
&lt;bound method Transmogriphier.activate ...&gt;
&gt;&gt;&gt; type(transmogriphy)
&lt;class &#39;method&#39;&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; type(transmogriphy) is types.MethodType
True</code></pre>
<h3 id="instances">Instances</h3>
<p>Notons qu’à ce stade <code>Transmogriphier</code> est invocable et la méthode <code>activate</code> des transmogriphieurs également. Mais les transmogriphieurs eux-même ne le sont pas :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(transmogriphier)
False</code></pre>
<p>Si nous estimons que c’est préférable, nous pouvons faire en sorte qu’ils le deviennent. Il semble assez raisonnable de faire en sorte qu’invoquer un transmogriphieur l’active :</p>
<pre class="python"><code>class Transmogriphier:
    def __init__(self, turn_into=&quot;tiger&quot;)
        self.turn_into = turn_into
    def activate(self, user):
        return self.turn_into
    def __call__(self, user):
        return self.activate(user)</code></pre>
<pre class="python"><code>&gt;&gt;&gt; transmogriphier = Transmogriphier()
&gt;&gt;&gt; callable(transmogriphier)
True</code></pre>
<p>Nous pouvons alors simplifier l’usage du transmogriphieur de la façon suivante :</p>
<pre class="python"><code>&gt;&gt;&gt; transmogriphier(&quot;calvin&quot;)
&#39;tiger&#39;</code></pre>
<h2 id="fonctions-génératrices">Fonctions génératrices</h2>
<p>Une fonction est <strong>génératrice</strong> si sa définition utilise le mot-clé <code>yield</code>.</p>
<ul>
<li><p>Appeler une fonction génératrice n’exécute pas son code immédiatement, mais fournit comme valeur de retour un itérateur.</p></li>
<li><p>Accéder au premier élément de cet itérateur exécute la fonction jusqu’à atteindre le premier <code>yield</code> ; la fonction renvoie alors la valeur fournie au <code>yield</code>, puis pause son exécution.</p></li>
<li><p>Accéder au second élément de cet itérateur reprend le fil de l’exécution à ce point, jusqu’à atteindre le second <code>yield</code>, etc.</p></li>
</ul>
<p>Ainsi, avec</p>
<pre class="python"><code>def one_two_three():
    yield 1
    yield 2
    yield 3</code></pre>
<p>on obtient</p>
<pre class="python"><code>&gt;&gt;&gt; for i in one_two_three():
...     print(i)
1
2
3</code></pre>
<p>et</p>
<pre class="python"><code>&gt;&gt;&gt; list(one_two_three())
[1, 2, 3]</code></pre>
<h4 id="exemples-source-itertools">Exemples (source: <a href="https://docs.python.org/3/library/itertools.html#module-itertools">itertools</a>)</h4>
<pre class="python"><code>def count(start=0, step=1):
    &quot;&quot;&quot;
    Generate the sequence start, start + step, start + 2*step, ...
    &quot;&quot;&quot;
    value = start
    while True:
        yield value
        value += step</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; odd_numbers = count(start=1, step=2)
&gt;&gt;&gt; for number in odd_numbers:
...     if number &gt;= 20:
...         break
...     else:
...         print(number, sep=&quot; &quot;)
1 3 5 7 9 11 13 15 17 19</code></pre>
<hr />
<pre class="python"><code>def cycle(iterable):
    &quot;&quot;&quot;
    Yield all items from an iterable, then repeat this output sequence indefinitely. 
    &quot;&quot;&quot;
    items = list(iterable)
    if items:
        for item in items:
            yield item</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; for i, item in enumerate(cycle(&quot;ABCD&quot;)):
...     if i &gt;= 12:
...         break
...     else:
...         print(item, sep=&quot; &quot;)
A B C D A B C D A B C D</code></pre>
<hr />
<pre class="python"><code>def repeat(object, n=None):
    &quot;&quot;&quot;
    Yield object an object n times (or indefinitely if n is None).
    &quot;&quot;&quot;
    if n is None:
        while True:
            yield object
    else:
        for i in range(n):
            yield object</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; list(repeat(10, 3))
[10, 10, 10]</code></pre>
<h4 id="exercices">Exercices</h4>
<ul>
<li><p>Implémentez votre propre version des fonctions standards <code>range</code>, <code>enumerate</code> et <code>zip</code> en utilisant les fonctions génératrices.</p></li>
<li><p>Revoyez la définition de la fonction <code>fibonacci</code> pour en faire une fonction génératrice, qui renvoie les nombres de Fibonnaci sous forme d’itérateur plutôt que de liste. Faites en sorte que lorsque l’argument <code>n</code> n’est pas fournie, l’itérateur parcoure l’intégralité de la suite.</p></li>
</ul>
<h2 id="programmation-fonctionnelle">Programmation fonctionnelle</h2>
<p>Un des traits de la <a href="https://fr.wikipedia.org/wiki/Programmation_fonctionnelle"><strong>programmation fonctionelle</strong></a>, un style de programmation que supporte (en partie) Python, est de permettre de manipuler les fonctions comme des objets comme les autres, pouvant être désignés par des variables, stockés dans des conteneurs, passés comme arguments à d’autres fonctions, etc. Une fonction acceptant comme argument des fonctions et/ou en renvoyant est une <strong>fonction d’ordre supérieur</strong> (🇺🇸 : <strong>higher-order function</strong>).</p>
<p>Les librairies mathématiques exploitent souvent avec profit ces fonctions d’ordre supérieures. Ainsi, la librairie de différentiation automatique <a href="https://github.com/HIPS/autograd#autograd---">Autograd</a> définit une fonction d’ordre supérieur <code>grad</code> qui associe à une fonction d’un argument réel sa dérivée :</p>
<p>Sa documentation donne l’exemple suivant d’usage :</p>
<pre class="python"><code>&gt;&gt;&gt; # Thinly-wrapped numpy
&gt;&gt;&gt; import autograd.numpy as np 
&gt;&gt;&gt; # The only autograd function you may ever need
&gt;&gt;&gt; from autograd import grad   
&gt;&gt;&gt; # Define a function
&gt;&gt;&gt; def tanh(x):                
...     y = np.exp(-2.0 * x)
...     return (1.0 - y) / (1.0 + y)
...
&gt;&gt;&gt; # Obtain its gradient function
&gt;&gt;&gt; grad_tanh = grad(tanh)       
&gt;&gt;&gt; # Evaluate the gradient at x = 1.0
&gt;&gt;&gt; grad_tanh(1.0)               
0.41997434161402603
&gt;&gt;&gt; # Compare to finite differences
&gt;&gt;&gt; (tanh(1.0001) - tanh(0.9999)) / 0.0002
0.41997434264973155</code></pre>
<p>Un autre usage important des fonctions d’ordre supérieur est l’exploitation de <strong>fonctions de rappels</strong> (🇺🇸 : <strong>callbacks</strong>), notamment dans les interfaces graphiques.</p>
<p>Par exemple, regardons comment est programmé l’application graphique donnée comme example dans <a href="http://tkdocs.com/tutorial/firstexample.html#design">le tutoriel de la bibliothèque Tk</a> :</p>
<figure>
<img src="images/converter.png" alt="Convertisseur de pieds en mètres" /><figcaption aria-hidden="true">Convertisseur de pieds en mètres</figcaption>
</figure>
<p>L’interface graphique est en partie définie par le code :</p>
<pre class="python"><code>from tkinter import *
from tkinter import ttk

root = Tk()
root.title(&quot;Feet to Meters&quot;)

mainframe = ttk.Frame(root, padding=&quot;3 3 12 12&quot;)
mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)

feet = StringVar()
feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
feet_entry.grid(column=2, row=1, sticky=(W, E))

meters = StringVar()
ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))</code></pre>
<p>Retenons simplement à ce stade que <code>root</code> est la fenêtre principale de l’application, <code>feet</code> le champ de texte où nous rentrons la valeur de la longueur en pieds et <code>meters</code> le champ de texte qui devra afficher la longueur équivalent en mètres.</p>
<p>Pour que l’application se comporte comme voulu, nous définissons une fonction <code>calculate</code> qui a chaque fois qu’elle est invoquée, lit la longueur en pied et écrit la longeur en mètres :</p>
<pre class="python"><code>def calculate(*args):
    try:
        value = float(feet.get())
        meters.set(int(0.3048 * value * 10000.0 + 0.5)/10000.0)
    except ValueError:
        pass</code></pre>
<p>Puis nous créons un bouton qui <strong>rappelle</strong> cette fonction (de rappel) à chaque fois qu’il est pressé :</p>
<pre class="python"><code>ttk.Button(
    mainframe, 
    text=&quot;Calculate&quot;, 
    command=calculate
).grid(column=3, row=3, sticky=W)</code></pre>
<p>Quelques labels de plus dans l’interface graphique, un peu de positionnement, et nous sommes prếts à lancer la boucle d’exécution du code !</p>
<pre class="python"><code>ttk.Label(mainframe, text=&quot;feet&quot;).grid(column=3, row=1, sticky=W)
ttk.Label(mainframe, text=&quot;is equivalent to&quot;).grid(column=1, row=2, sticky=E)
ttk.Label(mainframe, text=&quot;meters&quot;).grid(column=3, row=2, sticky=W)

for child in mainframe.winfo_children(): 
    child.grid_configure(padx=5, pady=5)

feet_entry.focus()

root.mainloop()</code></pre>
<h3 id="lambda">Lambda</h3>
<p>Les <strong>fonctions lambda</strong> en Python sont une construction qui n’augmente pas l’expressivité du langage – on ne peut rien faire avec des fonctions lambda qu’on ne pouvait déjà faire avec les fonctions classiques – mais permet dans certains cas d’obtenir un code plus concis.</p>
<p>Ainsi, pour trouver numériquement le zéro de la fonction <span class="math inline">\(x \mapsto x^2 - 2\)</span> entre <span class="math inline">\(0\)</span> et <span class="math inline">\(2\)</span> avec <code>scipy</code>, après avoir importé une fonction de recherche de racines</p>
<pre class="python"><code>from scipy.optimize import root_scalar as find_root</code></pre>
<p>on peut définir la fonction qui nous intéresse, ce qui suppose de la nommer (par exemple <code>f</code>) :</p>
<pre class="python"><code>def f(x):
    return x*x - 2</code></pre>
<p>puis appeler la routine de recherche de zéros de <code>scipy</code></p>
<pre class="python"><code>&gt;&gt;&gt; find_root(f, bracket=[0, 2])
      converged: True
           flag: &#39;converged&#39;
 function_calls: 9
     iterations: 8
           root: 1.4142135623731364</code></pre>
<p>Mais on peut aussi passer l’étape préalable de définition et de nommage de la function, et faire cet opération à la volée, dans l’appel à <code>find_root</code>, au moyen d’une fonction lambda :</p>
<pre class="python"><code>&gt;&gt;&gt; find_root(lambda x: x*x-2, bracket=[0, 2])
      converged: True
           flag: &#39;converged&#39;
 function_calls: 9
     iterations: 8
           root: 1.4142135623731364</code></pre>
<p>Le mot-clé <code>lambda</code> fait référence à la notation traditionnelle du <a href="https://fr.wikipedia.org/wiki/Lambda-calcul"><span class="math inline">\(\lambda\)</span>-calcul</a> ; on y désignerait la fonction <span class="math inline">\(x \mapsto x^2+1\)</span> par la notation <span class="math inline">\((\lambda x.x^2+1)\)</span>.</p>
<h3 id="fermetures">Fermetures</h3>
<p>Ainsi parlait Wikipédia :</p>
<blockquote>
<p>Dans un langage de programmation, une <strong>fermeture</strong> ou <strong>clôture</strong> (🇺🇸 : <strong>closure</strong>) est une fonction accompagnée de son environnement lexical.</p>
<p>L’<strong>environnement lexical</strong> d’une fonction est l’ensemble des variables non locales qu’elle a capturées, soit par valeur (c’est-à-dire par copie des valeurs des variables), soit par référence (c’est-à-dire par copie des adresses mémoires des variables).</p>
<p>Une fermeture est donc créée, entre autres, lorsqu’une fonction est définie dans le corps d’une autre fonction et utilise des paramètres ou des variables locales de cette dernière.</p>
<p>Source : <a href="https://fr.wikipedia.org/wiki/Fermeture_(informatique)"><img src="icons/Wikipedia.svg" style="height: 1em; display: inline; vertical-align: -0.175em;" /> Fermeture (informatique)</a></p>
</blockquote>
<p>Essayons de donner un exemple concret illustrant cette définition.</p>
<h4 id="evaluateur-dexpression">Evaluateur d’expression</h4>
<p>La fonction standard <code>eval</code> permet de calculer la valeur d’expressions représentées par des chaînes de caractères. Ainsi :</p>
<pre class="python"><code>&gt;&gt;&gt; x = 1 
&gt;&gt;&gt; y = 2
&gt;&gt;&gt; eval(&quot;x + y&quot;)
3</code></pre>
<p>Il est également possible d’ignorer l’espace de nom global et de spécifier explicitement l’espace de nom que devra utiliser l’évaluateur :</p>
<pre class="python"><code>&gt;&gt;&gt; namespace = {&quot;x&quot;: 3, &quot;y&quot;: 4}
&gt;&gt;&gt; eval(&quot;x + y&quot;, namespace)</code></pre>
<p>Nous aimerions disposer d’une fonction d’ordre supérieur – disons <code>fun</code> – qui associe à une expression, comme <code>"x+y"</code>, une fonction qui acceptera les arguments nommés nécessaires pour évaler l’expression – ici <code>x</code> et <code>y</code> – et renverra la valeur associée de l’expression.</p>
<p>Avec les fermetures de fonctions, rien de plus simple :</p>
<pre class="python"><code>def fun(expression):
    def f(**kwargs): 
       return eval(expression, kwargs)
    return f</code></pre>
<p>On remarquera que <code>eval(expression, kwargs)</code> utilise la variable <code>kwargs</code> qui est locale à <code>f</code> (car passée en paramètre). Mais elle utilise également <code>expression</code> qui est une variable locale de <code>fun</code> ; elle appartient à l’environnement lexical de <code>f</code> qui est donc une fermeture.</p>
<p>Voilà comment utiliser notre fonction <code>fun</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; add_xy = fun(&quot;x + y&quot;)
&gt;&gt;&gt; add_xy(x=4, y=5)
9</code></pre>
<hr />
<p>Les variables non-locales d’une fermeture sont accessibles en lecture seule par défaut. Pour les modifier, il faut au préalable les déclarer explicitement comme non-locales à la fermeture. (La situation est donc similaire celle des variables globales exploitées dans les fonctions.)</p>
<p>Par exemple, la fonction <code>make_get_set</code> génère deux fermetures qui accèdent à la même variable <code>x</code> (qui est locale à <code>make_get_set</code>) : <code>get</code> permet de lire la valeur de <code>x</code> et n’a donc pas besoin de la déclarer comme non-locale ; mais <code>set</code> doit permettre de changer la valeur de cette variable et la déclare donc comme non-locale :</p>
<pre class="python"><code>def make_get_set(x):
     def get():
         return x
     def set(value):
         nonlocal x
         x = value
     return get, set</code></pre>
<p>Exemple d’usage de ces fonctions :</p>
<pre class="python"><code>&gt;&gt;&gt; get, set = make_get_set(1)
&gt;&gt;&gt; get()
1
&gt;&gt;&gt; set(5)
&gt;&gt;&gt; get()
5</code></pre>
<hr />
<p>Il est bon de savoir que les variables non-locales sont capturées par référence en Python, et non par valeur, ce qui peut dans certains cas rendre votre vie … intéressante ! 😂</p>
<p>Par exemple, le programmeur ayant écrit</p>
<pre class="python"><code>def make_actions():
    actions = []
    for i in range(3):
        def printer():
            print(i)
        actions.append(printer)
    return actions</code></pre>
<p>s’attend probablement à générer une liste de 3 actions qui afficheront respectivement 0, 1 et 2 lorsqu’elles seront appelées. Mais comme le <code>i</code> utilisé par la fonction <code>printer</code> est capturé par référence, sa valeur effective est déterminée uniquement au moment de l’appel <code>print(i)</code>. Hors à ce moment-là, la boucle <code>for</code> a déjà été exécutée, donc <code>i</code> vaut <code>2</code>. Par conséquent, on obtient en fait :</p>
<pre class="python"><code>&gt;&gt;&gt; for action in make_actions():
...     action()
2
2
2</code></pre>
<p>Le “hack” classique pour résoudre ce problème consiste à utiliser le fait que les arguments par défaut d’une fonction sont évalués lors de sa définition. Par conséquent, si l’on définit :</p>
<pre class="python"><code>def make_actions():
    actions = []
    for i in range(3):
        def printer(i=i):
            print(i)
        actions.append(printer)
    return actions</code></pre>
<p>on obtient comme souhaité</p>
<pre class="python"><code>&gt;&gt;&gt; for action in make_actions():
...     action()
0
1
2</code></pre>
<h3 id="décorateurs">Décorateurs</h3>
<p>Les <strong>décorateurs</strong> sont un “sucre syntaxique” utilisant le symbole <code>@</code> et facilitant la mise en d’oeuvre d’un schéma assez courant que nous allons illustrer sur un exemple.</p>
<p>Imaginons que nous ayons développé une fonction <code>plus_one</code></p>
<pre class="python"><code>def plus_one(x):
    return x + 1</code></pre>
<p>mais qu’en la testant dans un programme, nous trouvons son comportement mystérieux. Pour comprendre ce qui se passe, nous modifions sa définition pour afficher ses arguments et les valeurs qu’elle renvoie à chaque fois qu’elle est appelée.</p>
<pre class="python"><code>def plus_one(x):
    print(&quot;input:&quot;, x)
    y = x + 1
    print(&quot;output:&quot;, y)
    return y</code></pre>
<p>avec la ferme intention de retirer ce code supplémentaire une fois le mystère éclairci.</p>
<p>Ce procédé n’est toutefois pas très satisfaisant. Plutôt que de modifier le code de <code>plus_one</code>, nous pouvons développer une fonction <code>debug</code> qui prendra la fonction <code>plus_one</code> comme argument et renverra une nouvelle fonction qui fonctionne comme <code>plus_one</code> à ceci près qu’elle affiche les arguments et la valeur de sortie :</p>
<pre class="python"><code>def debug(f):
    def f_debug(x):
        print(&quot;input:&quot;, x)
        y = f(x)
        print(&quot;output:&quot;, y)
        return y
    return f_debug</code></pre>
<p>Pour tester le code en situation réelle, il nous suffit alors de remplacer la fonction <code>plus_one</code> classique par cette nouvelle fonction</p>
<pre class="python"><code>plus_one = debug(plus_one)</code></pre>
<p>puis d’effacer uniquement cette ligne supplémentaire une fois le mystère éclairci.</p>
<p>Il s’avère que le code</p>
<pre class="python"><code>def plus_one(x):
    return x + 1

plus_one = debug(plus_one)</code></pre>
<p>est équivalent à la construction suivante utilisant les décorateurs :</p>
<pre class="python"><code>@debug
def plus_one(x):
    return x + 1</code></pre>
<p>On pourra trouver cette seconde notation plus agréable et lisible !</p>
<h4 id="exemple">Exemple</h4>
<p>La fonction d’ordre supérieur <code>count</code> ci-dessous peut être utilisée en conjonction avec un décorateur pour enregistrer le nombre de fois où une fonction a été invoquée (le nombre d’appels de la fonction est stocké dans l’attribut <code>count</code> de la fonction).</p>
<pre class="python"><code>def count(f):
    def counted_f(x):
        counted_f.count += 1
        return f(x)
    counted_f.count = 0
    return counted_f</code></pre>
<p>Par exemple, si l’on recherche à localiser l’unique zéro de la fonction <span class="math inline">\(x \mapsto x^2 - 2\)</span>, qui est <span class="math inline">\(\sqrt{2}\)</span>, on peut la définir en la décorant avec <code>@count</code> :</p>
<pre class="python"><code>@count
def f(x):
    return x*x - 2</code></pre>
<p>Puis procéder par itérations successives pour produire une estimation de <span class="math inline">\(\sqrt{2}\)</span> :</p>
<pre class="python"><code>&gt;&gt;&gt; f(0)
-2
&gt;&gt;&gt; f(1)
-1
&gt;&gt;&gt; f(2)
2
&gt;&gt;&gt; f(1.5)
0.25
&gt;&gt;&gt; f(1.4)
-0.04000000000000026
&gt;&gt;&gt; f(1.45)
0.10250000000000004
&gt;&gt;&gt; f(1.43)
0.04489999999999972
&gt;&gt;&gt; f(1.42)
0.01639999999999997
&gt;&gt;&gt; f(1.41)
-0.011900000000000244</code></pre>
<p>Et constater à posteriori combien d’appels de la fonction <code>f</code> ont été nécessaires :</p>
<pre class="python"><code>&gt;&gt;&gt; f.count
9</code></pre>
</body>
</html>
