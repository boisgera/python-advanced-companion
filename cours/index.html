<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Fonctions</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <link rel="stylesheet" href="css/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!--
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet"> 
  -->

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap" rel="stylesheet"> 
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@300;400;500;600;700&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&display=swap" rel="stylesheet">
  <script>
      document.addEventListener("DOMContentLoaded", (event) => {
          let h3 = document.createElement("h3");
          h3.innerHTML = "Table des matières";
          let toc = document.getElementById("TOC");
          toc.prepend(h3);
      });    
  </script>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Fonctions</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#fonctions">Fonctions</a>
<ul>
<li><a href="#définitions">Définitions</a></li>
<li><a href="#valeurs-de-retour">Valeurs de retour</a></li>
<li><a href="#espaces-de-nom">Espaces de nom</a></li>
</ul></li>
<li><a href="#invocables">Invocables</a>
<ul>
<li><a href="#types">Types</a></li>
<li><a href="#méthodes">Méthodes</a></li>
<li><a href="#instances">Instances</a></li>
</ul></li>
<li><a href="#fonctions-génératrices">Fonctions génératrices</a></li>
<li><a href="#programmation-fonctionnelle">Programmation fonctionnelle</a>
<ul>
<li><a href="#fonctions-lambda-ou-anonymes">Fonctions lambda (ou anonymes)</a></li>
<li><a href="#fermetures-de-fonctions">Fermetures (de fonctions)</a></li>
<li><a href="#décorateurs">Décorateurs</a></li>
</ul></li>
</ul>
</nav>
<h2 id="fonctions">Fonctions</h2>
<h3 id="définitions">Définitions</h3>
<p><code>def</code> <code>return</code>, retour réifiés (tuple), arguments positionnels ou nommés, arguments par défaut.</p>
<pre class="python"><code>def f(x, y, z=0):
    print(&quot;Please !&quot;)
    return 42</code></pre>
<p>Mentionner type hints (ex avec Typer ?).</p>
<h3 id="valeurs-de-retour">Valeurs de retour</h3>
<p><span class="math display">\[
\int_0^1 f(x) \, dx
\]</span></p>
<h3 id="espaces-de-nom">Espaces de nom</h3>
<p>Portée / scope</p>
<p>🇺🇸 → Namespace</p>
<p>(implicites)</p>
<p>globals / locals (builtin module, read-only, etc.)</p>
<h2 id="invocables">Invocables</h2>
<p>On qualifie d’invocable (ou appelable ; 🇺🇸 : callable) tout objet se comportant comme une fonction, c’est-à-dire pouvant être appelé (invoqué) avec la même syntaxe que les fonctions.</p>
<p>Ainsi, l’entier <code>0</code> n’est pas invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; zero = 0
&gt;&gt;&gt; zero()
TypeError: &#39;int&#39; object is not callable</code></pre>
<p>mais la fonction sans argument qui renvoie <code>0</code> est invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; def zero_fun():
...     return 0
&gt;&gt;&gt; zero_fun()
0</code></pre>
<p>ce qui n’est pas une surprise puisque c’est une fonction !</p>
<pre class="python"><code>&gt;&gt;&gt; type(zero_fun)
&lt;class &#39;function&#39;&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; isinstance(zero_fun, types.FunctionType)
True</code></pre>
<p>L’invocabilité des objets Python peut être testée avec la fonction <code>callable</code> :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(zero)
False
&gt;&gt;&gt; callable(zero_fun)
True</code></pre>
<p>Notons que ce test permet de dire si un objet est invocable, mais pas si on peut l’invoquer sans arguments (ni combien d’arguments sont nécessaires, de quel type, etc.). Ainsi :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(hash)
True</code></pre>
<p>Mais</p>
<pre class="python"><code>&gt;&gt;&gt; hash()
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: hash() takes exactly one argument (0 given)</code></pre>
<p>Toutefois</p>
<pre class="python"><code>&gt;&gt;&gt; hash(2**100)
549755813888</code></pre>
<p>Pour en savoir plus sur les arguments attendus, il faudra se reporter à la documentation de l’objet considéré.</p>
<h3 id="types">Types</h3>
<p>Un objet comme <code>int</code> est également invocable :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(int)
True</code></pre>
<p>ce que l’on peut rapidement confirmer expérimentalement :</p>
<pre class="python"><code>&gt;&gt;&gt; int()
0
&gt;&gt;&gt; int(0.0)
0
&gt;&gt;&gt; int(&quot;0&quot;)
0</code></pre>
<p>Pourtant, ce n’est pas une function, mais un type :</p>
<pre class="python"><code>&gt;&gt;&gt; type(int)
&lt;class &#39;type&#39;&gt;
&gt;&gt;&gt; type(int) is type  # 🤯
True
&gt;&gt;&gt; isinstance(int, types.FunctionType)
False</code></pre>
<p>Rappelons que les types (ou classes) ont vocation, quand on les appelle, à créer des instances du type considéré :</p>
<pre class="python"><code>&gt;&gt;&gt; isinstance(int(), int)
True
&gt;&gt;&gt; isinstance(int(0.0), int)
True
&gt;&gt;&gt; isinstance(int(&quot;0&quot;), int)
True</code></pre>
<p>Les classes que vous définissez sont également invocables :</p>
<pre class="python"><code>class Transmogrifier:
    pass</code></pre>
<pre class="python"><code>&gt;&gt;&gt; callable(Transmogriphier)
True
&gt;&gt;&gt; transmogriphier = Transmogriphier()
&gt;&gt;&gt; isinstance(transmogriphier, Transmogrifier)
True</code></pre>
<h3 id="méthodes">Méthodes</h3>
<p>Un <a href="https://calvinandhobbes.fandom.com/wiki/Transmogrifier">transmogriphieur</a> peut transformer son utilisateur en ce qu’il souhaite (par défaut, un tigre 🐯 ; <a href="https://static.wikia.nocookie.net/candh/images/6/60/Tigercalvin.png/revision/latest?cb=20111208210956">mais on n’a pas spécifié sa taille</a> !).</p>
<!-- not rendered on Github
![[Calvin transformé en tigre](https://calvinandhobbes.fandom.com/wiki/Calvin_in_Tiger_Form_(Transmogrifier_alter_ego))](https://static.wikia.nocookie.net/candh/images/6/60/Tigercalvin.png/revision/latest?cb=20111208210956)
-->
<pre class="python"><code>class Transmogriphier:
    def __init__(self, turn_into=&quot;tiger&quot;):
        self.turn_into = turn_into
    def activate(self, user):
        return self.turn_into</code></pre>
<pre class="python"><code>&gt;&gt;&gt; transmogriphier = Transmogriphier()
&gt;&gt;&gt; transmogriphier.activate(&quot;calvin&quot;)
&#39;tiger&#39;</code></pre>
<p>L’opération <code>transmogriphier.activate("calvin")</code> n’est pas “atomique” : elle consiste d’abord à obtenir l’attribut <code>activate</code> de l’objet <code>transmogriphier</code>, puis à l’invoquer avec l’argument <code>"calvin"</code>.</p>
<pre class="python"><code>&gt;&gt;&gt; transmogriphy = transmogriphier.activate
&gt;&gt;&gt; callable(transmogriphy)
True
&gt;&gt;&gt; transmogriphy(&quot;calvin&quot;)
&#39;tiger&#39;</code></pre>
<p>Cela est possible car <code>activate</code> est une méthode (liée à l’instance <code>transmogriphier</code> de <code>Transmogriphier</code>) et est donc invocable.</p>
<pre class="python"><code>&gt;&gt;&gt; transmogriphy
&lt;bound method Transmogriphier.activate ...&gt;
&gt;&gt;&gt; type(transmogriphy)
&lt;class &#39;method&#39;&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; type(transmogriphy) is types.MethodType
True</code></pre>
<h3 id="instances">Instances</h3>
<p>Notons qu’à ce stade <code>Transmogriphier</code> est invocable et la méthode <code>activate</code> des transmogriphieurs également. Mais les transmogriphieurs eux-même ne le sont pas :</p>
<pre class="python"><code>&gt;&gt;&gt; callable(transmogriphier)
False</code></pre>
<p>Si nous estimons que c’est préférable, nous pouvons faire en sorte qu’ils le deviennent. Il semble assez raisonnable de faire en sorte qu’invoquer un transmogriphieur l’active :</p>
<pre class="python"><code>class Transmogriphier:
    def __init__(self, turn_into=&quot;tiger&quot;)
        self.turn_into = turn_into
    def activate(self, user):
        return self.turn_into
    def __call__(self, user):
        return self.activate(user)</code></pre>
<pre class="python"><code>&gt;&gt;&gt; transmogriphier = Transmogriphier()
&gt;&gt;&gt; callable(transmogriphier)
True</code></pre>
<p>Nous pouvons alors simplifier l’usage du transmogriphieur de la façon suivante :</p>
<pre class="python"><code>&gt;&gt;&gt; transmogriphier(&quot;calvin&quot;)
&#39;tiger&#39;</code></pre>
<h2 id="fonctions-génératrices">Fonctions génératrices</h2>
<p>Une fonction est génératrice si sa définition utilise le mot-clé <code>yield</code>.</p>
<ul>
<li><p>Appeler une fonction génératrice n’exécute pas son code immédiatement, mais fournit comme valeur de retour un itérateur.</p></li>
<li><p>Accéder au premier élément de cet itérateur exécute la fonction jusqu’à atteindre le premier <code>yield</code> ; la fonction renvoie alors la valeur fournie au <code>yield</code>, puis pause son exécution.</p></li>
<li><p>Accéder au second élément de cet itérateur reprend le fil de l’exécution à ce point, jusqu’à atteindre le second <code>yield</code>, etc.</p></li>
</ul>
<p>Ainsi, avec</p>
<pre class="python"><code>def one_two_three():
    yield 1
    yield 2
    yield 3</code></pre>
<p>on obtient</p>
<pre class="python"><code>&gt;&gt;&gt; for i in one_two_three():
...     print(i)
1
2
3</code></pre>
<p>et</p>
<pre class="python"><code>&gt;&gt;&gt; list(one_two_three())
[1, 2, 3]</code></pre>
<h4 id="exemples-source-itertools">Exemples (source: <a href="https://docs.python.org/3/library/itertools.html#module-itertools">itertools</a>)</h4>
<pre class="python"><code>def count(start=0, step=1):
    &quot;&quot;&quot;
    Generate the sequence start, start + step, start + 2*step, ...
    &quot;&quot;&quot;
    value = start
    while True:
        yield value
        value += step</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; odd_numbers = count(start=1, step=2)
&gt;&gt;&gt; for number in odd_numbers:
...     if number &gt;= 20:
...         break
...     else:
...         print(number, sep=&quot; &quot;)
1 3 5 7 9 11 13 15 17 19</code></pre>
<hr />
<pre class="python"><code>def cycle(iterable):
    &quot;&quot;&quot;
    Yield all items from an iterable, then repeat the same output sequence indefinitely. 
    &quot;&quot;&quot;
    items = list(iterable)
    if items:
        for item in items:
            yield item</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; for i, item in enumerate(cycle(&quot;ABCD&quot;)):
...     if i &gt;= 12:
...         break
...     else:
...         print(item, sep=&quot; &quot;)
A B C D A B C D A B C D</code></pre>
<hr />
<pre class="python"><code>def repeat(object, n=None):
    &quot;&quot;&quot;
    Yield object an object n times (or indefinitely if n is None).
    &quot;&quot;&quot;
    if n is None:
        while True:
            yield object
    else:
        for i in range(n):
            yield object</code></pre>
<p>Usage :</p>
<pre class="python"><code>&gt;&gt;&gt; list(repeat(10, 3))
[10, 10, 10]</code></pre>
<h4 id="exercices">Exercices</h4>
<p>Implémentez votre propre version des fonctions standards <code>range</code>, <code>enumerate</code> et <code>zip</code> en utilisant les fonctions génératrices.</p>
<h2 id="programmation-fonctionnelle">Programmation fonctionnelle</h2>
<p>Un des traits de la [programmation fonctionelle], un style de programmation que supporte (en partie) Python, est de permettre de manipuler les fonctions comme des objets comme les autres, pouvant être désigné par une variable, stockés dans des conteneurs, passé comme arguments à des fonctions, etc. Une fonction acceptant comme argument des fonctions et/ou en renvoyant est une fonction d’ordre supérieur.</p>
<p>Les librairies mathématiques exploitent souvent avec profit ces fonctions d’ordre supérieures. Ainsi, la librairie de différentiation automatique <a href="https://github.com/HIPS/autograd#autograd---">Autograd</a> définit une fonction d’ordre supérieure <code>grad</code> qui associe à une fonction d’un argument réel sa dérivée :</p>
<p>Sa documentation donne l’exemple suivant d’usage :</p>
<pre class="python"><code>&gt;&gt;&gt; # Thinly-wrapped numpy
&gt;&gt;&gt; import autograd.numpy as np 
&gt;&gt;&gt; # The only autograd function you may ever need
&gt;&gt;&gt; from autograd import grad   
&gt;&gt;&gt; # Define a function
&gt;&gt;&gt; def tanh(x):                
...     y = np.exp(-2.0 * x)
...     return (1.0 - y) / (1.0 + y)
...
&gt;&gt;&gt; # Define a function
&gt;&gt;&gt; grad_tanh = grad(tanh)       
&gt;&gt;&gt; # Evaluate the gradient at x = 1.0
&gt;&gt;&gt; grad_tanh(1.0)               
0.41997434161402603
&gt;&gt;&gt; # Compare to finite differences
&gt;&gt;&gt; (tanh(1.0001) - tanh(0.9999)) / 0.0002
0.41997434264973155</code></pre>
<p>Un autre usage important des fonctions d’ordre supérieur est l’exploitation de <strong>fonctions de rappels</strong> (🇺🇸 : callbacks), notamment dans les interfaces graphiques.</p>
<p>Par exemple, regardons comment est programmé l’application graphique donnée comme example dans <a href="http://tkdocs.com/tutorial/firstexample.html#design">le tutoriel de la bibliothèque Tk</a>.</p>
<figure>
<img src="images/converter.png" alt="Convertisseur de pieds en mètres" /><figcaption aria-hidden="true">Convertisseur de pieds en mètres</figcaption>
</figure>
<p>L’interface graphique est en partie définie par le code :</p>
<pre class="python"><code>from tkinter import *
from tkinter import ttk

root = Tk()
root.title(&quot;Feet to Meters&quot;)

mainframe = ttk.Frame(root, padding=&quot;3 3 12 12&quot;)
mainframe.grid(column=0, row=0, sticky=(N, W, E, S))
root.columnconfigure(0, weight=1)
root.rowconfigure(0, weight=1)

feet = StringVar()
feet_entry = ttk.Entry(mainframe, width=7, textvariable=feet)
feet_entry.grid(column=2, row=1, sticky=(W, E))

meters = StringVar()
ttk.Label(mainframe, textvariable=meters).grid(column=2, row=2, sticky=(W, E))</code></pre>
<p>Retenons simplement à ce stade que <code>root</code> est la fenêtre principale de l’application, <code>feet</code> le champ de texte où nous rentrons la valeur de la longueur en pieds et <code>meters</code> le champ de texte qui devra afficher la longueur équivalent en mètres.</p>
<p>Pour que l’application se comporte comme voulu, nous définissons une fonction <code>calculate</code> qui a chaque fois qu’elle est invoquée, lit la longueur en pied et affiche la longeur en mètres :</p>
<pre class="python"><code>def calculate(*args):
    try:
        value = float(feet.get())
        meters.set(int(0.3048 * value * 10000.0 + 0.5)/10000.0)
    except ValueError:
        pass</code></pre>
<p>Puis nous créons un bouton qui rappelle cette fonction à chaque fois qu’il est pressé :</p>
<pre class="python"><code>ttk.Button(
    mainframe, 
    text=&quot;Calculate&quot;, 
    command=calculate
).grid(column=3, row=3, sticky=W)</code></pre>
<p>Quelques labels de plus dans l’interface graphique, un peu de positionnement, et nous sommes prếts à lancer la boucle d’exécution du code !</p>
<pre class="python"><code>ttk.Label(mainframe, text=&quot;feet&quot;).grid(column=3, row=1, sticky=W)
ttk.Label(mainframe, text=&quot;is equivalent to&quot;).grid(column=1, row=2, sticky=E)
ttk.Label(mainframe, text=&quot;meters&quot;).grid(column=3, row=2, sticky=W)

for child in mainframe.winfo_children(): 
    child.grid_configure(padx=5, pady=5)

feet_entry.focus()

root.mainloop()</code></pre>
<pre class="python"><code>root.mainloop()</code></pre>
<h3 id="fonctions-lambda-ou-anonymes">Fonctions lambda (ou anonymes)</h3>
<p>Les fonctions lambda en Python sont une construction qui n’augmente pas l’expressivité du langage – on ne peut rien faire avec des fonctions lambda qu’on ne pouvait déjà faire avec les fonctions classiques – mais permet dans certains cas d’obtenir un code plus concis.</p>
<p>Ainsi, pour trouver numériquement le zéro de la fonction <span class="math inline">\(x \mapsto x^2 - 2\)</span> entre <span class="math inline">\(0\)</span> et <span class="math inline">\(2\)</span> avec <code>scipy</code>, après avoir importé une fonction de recherche de racines</p>
<pre class="python"><code>&gt;&gt;&gt; from scipy.optimize import root_scalar as find_root</code></pre>
<p>on peut définir la fonction qui nous intéresse, ce qui suppose de la nommer (par exemple <code>f</code>) :</p>
<pre class="python"><code>&gt;&gt;&gt; def f(x):
...     return x*x - 2</code></pre>
<p>puis appeler la routine de recherche de zéros de <code>scipy</code></p>
<pre class="python"><code>&gt;&gt;&gt; find_root(f, bracket=[0, 2])
      converged: True
           flag: &#39;converged&#39;
 function_calls: 9
     iterations: 8
           root: 1.4142135623731364</code></pre>
<p>Mais on peut aussi passer l’étape préalable de définition et de nommage de la function, et faire cet opération à la volée, dans l’appel à <code>find_root</code>, au moyen d’une fonction lambda :</p>
<pre class="python"><code>&gt;&gt;&gt; find_root(lambda x: x*x-2, bracket=[0, 2])
      converged: True
           flag: &#39;converged&#39;
 function_calls: 9
     iterations: 8
           root: 1.4142135623731364</code></pre>
<p>Le mot-clé <code>lambda</code> fait référence à la notation traditionnelle du <a href="https://fr.wikipedia.org/wiki/Lambda-calcul"><span class="math inline">\(\lambda\)</span>-calcul</a>.</p>
<h3 id="fermetures-de-fonctions">Fermetures (de fonctions)</h3>
<blockquote>
<p>Dans un langage de programmation, une fermeture ou clôture (🇺🇸 : <em>closure</em>) est une fonction accompagnée de son environnement lexical.</p>
<p>L’environnement lexical d’une fonction est l’ensemble des variables non locales qu’elle a capturées, soit par valeur (c’est-à-dire par copie des valeurs des variables), soit par référence (c’est-à-dire par copie des adresses mémoires des variables).</p>
<p>Une fermeture est donc créée, entre autres, lorsqu’une fonction est définie dans le corps d’une autre fonction et utilise des paramètres ou des variables locales de cette dernière.</p>
<p>Source : <a href="https://fr.wikipedia.org/wiki/Fermeture_(informatique)">Wikipedia</a></p>
</blockquote>
<h3 id="décorateurs">Décorateurs</h3>
<p>Les décorateurs sont un “sucre syntaxique” utilisant le symbole <code>@</code> et facilitant la mise en d’oeuvre d’un schéma assez courant que nous allons illustrer sur un exemple.</p>
<p>Imaginons que nous ayons développé une fonction <code>plus_one</code></p>
<pre class="python"><code>def plus_one(x):
    return x + 1</code></pre>
<p>mais qu’en la testant dans un programme, nous trouvons son comportement mystérieux. Pour comprendre ce qui se passe, nous modifions sa définition pour afficher ses arguments et les valeurs qu’elle renvoie à chacun de ses appels.</p>
<pre class="python"><code>def plus_one(x):
    print(&quot;input:&quot;, x)
    y = x + 1
    print(&quot;output:&quot;, y)
    return y</code></pre>
<p>avec la ferme intention de retirer ce code supplémentaire une fois le mystère éclairci.</p>
<p>Ce procédé n’est toutefois pas très satisfaisant. Plutôt que de modifier le code de <code>plus_one</code>, nous pouvons développer une fonction <code>debug</code> qui prendra la fonction <code>plus_one</code> comme argument et renverra une nouvelle fonction qui fonctionne comme <code>plus_one</code> à ceci près qu’elle affiche les arguments et la valeur de sortie :</p>
<pre class="python"><code>def debug(f):
    def f_debug(x):
        print(&quot;input:&quot;, x)
        y = f(x)
        print(&quot;output:&quot;, y)
        return y
    return f_debug</code></pre>
<p>Pour tester le code en situation réelle, il nous suffit alors de remplacer la fonction <code>plus_one</code> classique par cette nouvelle fonction</p>
<pre class="python"><code>plus_one = debug(plus_one)</code></pre>
<p>puis d’effacer uniquement cette ligne supplémentaire une fois le mystère éclairci.</p>
<p>Il s’avère que le code</p>
<pre class="python"><code>def plus_one(x):
    return x + 1

plus_one = debug(plus_one)</code></pre>
<p>est équivalent à la construction suivante utilisant les décorateurs :</p>
<pre class="python"><code>@debug
def plus_one(x):
    return x + 1</code></pre>
<p>On pourra trouver cette seconde notation plus agréable et lisible !</p>
<h4 id="exemples">Exemples</h4>
<p>Le décorateur <code>count</code> ci-dessous peut être utilisé pour enregistrer le nombre de fois où une fonction a été invoquée (le nombre d’appels de la fonction est stocké dans l’attribut <code>count</code> de la fonction).</p>
<pre class="python"><code>def count(f):
    def counted_f(x):
        counted_f.count += 1
        return f(x)
    counted_f.count = 0
    return counted_f</code></pre>
<p>Par exemple, si l’on recherche à localiser l’unique zéro de la fonction <span class="math inline">\(x \mapsto x^2 - 2\)</span>, qui est <span class="math inline">\(\sqrt{2}\)</span>, on peut la définir en la décorant avec la fonction d’ordre supérieur <code>count</code> :</p>
<pre class="python"><code>@count
def f(x):
    return x*x - 2</code></pre>
<p>Puis procéder par itérations successives pour produire une estimation de <span class="math inline">\(\sqrt{2}\)</span> :</p>
<pre class="python"><code>&gt;&gt;&gt; f(0)
-2
&gt;&gt;&gt; f(1)
-1
&gt;&gt;&gt; f(2)
2
&gt;&gt;&gt; f(1.5)
0.25
&gt;&gt;&gt; f(1.4)
-0.04000000000000026
&gt;&gt;&gt; f(1.45)
0.10250000000000004
&gt;&gt;&gt; f(1.43)
0.04489999999999972
&gt;&gt;&gt; f(1.42)
0.01639999999999997
&gt;&gt;&gt; f(1.41)
-0.011900000000000244</code></pre>
<p>Et constater à posteriori combien d’appels de la fonction <code>f</code> ont été nécessaires :</p>
<pre class="python"><code>&gt;&gt;&gt; f.count
9</code></pre>
</body>
</html>
