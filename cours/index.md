---
title: Fonctions
---

Fonctions
--------------------------------------------------------------------------------

### DÃ©finitions

`def` `return`, retour rÃ©ifiÃ©s (tuple), arguments positionnels ou nommÃ©s,
arguments par dÃ©faut.

``` python
def f(x, y, z=0):
    print("Please !")
    return 42
```

Mentionner type hints (ex avec Typer ?).

### Valeurs de retour

$$
\int_0^1 f(x) \, dx
$$

### Espaces de nom

PortÃ©e / scope

ðŸ‡ºðŸ‡¸ â†’ Namespace 

(implicites)

globals / locals (builtin module, read-only, etc.)


Invocables
--------------------------------------------------------------------------------

ðŸ‡«ðŸ‡· invocable (ou appelable)  â†’ ðŸ‡ºðŸ‡¸ callable (or "function-like")

On qualifie d'invocable tout objet se comportant comme une fonction,
c'est-Ã -dire pouvant Ãªtre appelÃ© (invoquÃ©) avec la mÃªme syntaxe que
les fonctions.

Ainsi, l'entier `0` n'est pas invocable :

``` pycon
>>> zero = 0
>>> zero()
TypeError: 'int' object is not callable
```

La fonction sans argument qui renvoie `0` est invocable :

``` pycon
>>> def zero_fun():
...     return 0
>>> zero_fun()
0
```

ce qui n'est pas une surprise puisque c'est une fonction !

``` pycon
>>> type(zero_fun)
<class 'function'>
>>> import types
>>> isinstance(zero_fun, types.FunctionType)
True
```

L'objet `int` est Ã©galement invocable :

``` pycon
>>> int()
0
```

Pourtant, ce n'est pas une function, mais un type (c'est-Ã -dire une classe) :

``` pycon
>>> type(int)
<class 'type'>
>>> type(int) is type
True
>>> isinstance(int, types.FunctionType)
False
```

L'invocabilitÃ© des objets Python peut Ãªtre testÃ©e avec la fonction `callable` :

``` pycon
>>> callable(zero)
False
>>> callable(zero_fun)
True
>>> callable(int)
True
```

Notons que ce test permet de dire si un objet est invocable, mais pas si
on peut l'invoquer sans arguments (ni combien d'arguments sont nÃ©cessaires,
de quel type, etc.). Ainsi :

``` pycon
>>> callable(hash)
True
```

Mais
``` pycon
>>> hash()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: hash() takes exactly one argument (0 given)
```

Toutefois
``` pycon
>>> hash(2**100)
549755813888
```

Pour en savoir plus sur les arguments attendus, il faudra se reporter 
Ã  la documentation de l'objet considÃ©rÃ©.


### Classes

Des fois difficile de distinguer classes de fonction (ex: `np.array`) ;
factories, etc.

### MÃ©thodes

### Custom classes

`__call__`


Fonctions gÃ©nÃ©ratrices
--------------------------------------------------------------------------------

Une fonction est gÃ©nÃ©ratrice si sa dÃ©finition utilise le mot-clÃ© `yield`.

Appeler une fonction gÃ©nÃ©ratrice n'exÃ©cute pas son code immÃ©diatement,
mais fournit comme valeur de retour un itÃ©rateur. Demander le premier Ã©lÃ©ment
de cet itÃ©rateur exÃ©cute la fonction jusqu'Ã  atteindre le premier 
`yield`; la fonction pause alors son exÃ©cution et renvoie la valeur 
fournie au `yield`. Demander le second objet reprend le fil de l'exÃ©cution
Ã  ce point, jusqu'Ã  atteindre le second `yield`, etc.

Ainsi, avec 

``` python
def one_two_three():
    yield 1
    yield 2
    yield 3
```

on obtient

``` pycon
>>> for i in one_two_three():
...     print(i)
1
2
3
```

et

``` pycon
>>> list(one_two_three())
[1, 2, 3]
```

#### Exemples ([itertools])

[itertools]: https://docs.python.org/3/library/itertools.html#module-itertools

``` python
def count(start=0, step=1):
    value = start
    while True:
        yield value
        value += step
```

``` pycon
>>> odd_numbers = count(1, 2)
>>> for number in odd_numbers:
...     print(number, sep=" ")
...     if number >= 20:
...         break
1 3 5 7 9 11 13 15 17 19 21
```

``` python
def cycle(iterable):
    saved = []
    for element in iterable:
        yield element
        saved.append(element)
    while saved:
        for element in saved:
              yield element
```



``` python
def repeat(object, times=None):
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object
```

``` pycon
>>> list(repeat(10, 3))
[10, 10, 10]
```

**TODO:**

  - expliquer analogie "return multiples" et flux d'exÃ©cution plus complexe
    qu'une fonction classique

  - arguments

  - code entre yields

  - exemple de flux d'exÃ©cution "complexes"

  - qq uses cases: Ã©mulation fonctionnalitÃ©s itertools (AVANT: range), etc.

  - valeur de retours



Higher-order Programming
--------------------------------------------------------------------------------

Fonctions comme "valeurs" ; lambda, decorateurs ; patterns d'usage: 
math (ODEs, autograd), filters/maps, callbacks, etc.

### Usages

### DÃ©corateurs

### Lambda

### Closures


--------------------------------------------------------------------------------

``` pycon
test ligatures: -> ==
```